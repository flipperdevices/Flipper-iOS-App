// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gui.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PBGui_InputKey: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case up // = 0
  case down // = 1
  case right // = 2
  case left // = 3
  case ok // = 4
  case back // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .up
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .up
    case 1: self = .down
    case 2: self = .right
    case 3: self = .left
    case 4: self = .ok
    case 5: self = .back
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .up: return 0
    case .down: return 1
    case .right: return 2
    case .left: return 3
    case .ok: return 4
    case .back: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBGui_InputKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBGui_InputKey] = [
    .up,
    .down,
    .right,
    .left,
    .ok,
    .back,
  ]
}

#endif  // swift(>=4.2)

enum PBGui_InputType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///*< Press event, emitted after debounce 
  case press // = 0

  ///*< Release event, emitted after debounce 
  case release // = 1

  ///*< Short event, emitted after InputTypeRelease done withing INPUT_LONG_PRESS interval 
  case short // = 2

  ///*< Long event, emmited after INPUT_LONG_PRESS interval, asynchronouse to InputTypeRelease  
  case long // = 3

  ///*< Repeat event, emmited with INPUT_REPEATE_PRESS period after InputTypeLong event 
  case `repeat` // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .press
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .press
    case 1: self = .release
    case 2: self = .short
    case 3: self = .long
    case 4: self = .repeat
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .press: return 0
    case .release: return 1
    case .short: return 2
    case .long: return 3
    case .repeat: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBGui_InputType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBGui_InputType] = [
    .press,
    .release,
    .short,
    .long,
    .repeat,
  ]
}

#endif  // swift(>=4.2)

enum PBGui_ScreenOrientation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///*< Horizontal 
  case horizontal // = 0

  ///*< Horizontal flipped (180)
  case horizontalFlip // = 1

  ///*< Vertical (90)
  case vertical // = 2

  ///*< Vertical flipped 
  case verticalFlip // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .horizontal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .horizontal
    case 1: self = .horizontalFlip
    case 2: self = .vertical
    case 3: self = .verticalFlip
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .horizontal: return 0
    case .horizontalFlip: return 1
    case .vertical: return 2
    case .verticalFlip: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBGui_ScreenOrientation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBGui_ScreenOrientation] = [
    .horizontal,
    .horizontalFlip,
    .vertical,
    .verticalFlip,
  ]
}

#endif  // swift(>=4.2)

struct PBGui_ScreenFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var orientation: PBGui_ScreenOrientation = .horizontal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBGui_StartScreenStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBGui_StopScreenStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBGui_SendInputEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: PBGui_InputKey = .up

  var type: PBGui_InputType = .press

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBGui_StartVirtualDisplayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// optional
  var firstFrame: PBGui_ScreenFrame {
    get {return _firstFrame ?? PBGui_ScreenFrame()}
    set {_firstFrame = newValue}
  }
  /// Returns true if `firstFrame` has been explicitly set.
  var hasFirstFrame: Bool {return self._firstFrame != nil}
  /// Clears the value of `firstFrame`. Subsequent reads from it will return its default value.
  mutating func clearFirstFrame() {self._firstFrame = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _firstFrame: PBGui_ScreenFrame? = nil
}

struct PBGui_StopVirtualDisplayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PBGui_InputKey: @unchecked Sendable {}
extension PBGui_InputType: @unchecked Sendable {}
extension PBGui_ScreenOrientation: @unchecked Sendable {}
extension PBGui_ScreenFrame: @unchecked Sendable {}
extension PBGui_StartScreenStreamRequest: @unchecked Sendable {}
extension PBGui_StopScreenStreamRequest: @unchecked Sendable {}
extension PBGui_SendInputEventRequest: @unchecked Sendable {}
extension PBGui_StartVirtualDisplayRequest: @unchecked Sendable {}
extension PBGui_StopVirtualDisplayRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB_Gui"

extension PBGui_InputKey: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UP"),
    1: .same(proto: "DOWN"),
    2: .same(proto: "RIGHT"),
    3: .same(proto: "LEFT"),
    4: .same(proto: "OK"),
    5: .same(proto: "BACK"),
  ]
}

extension PBGui_InputType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESS"),
    1: .same(proto: "RELEASE"),
    2: .same(proto: "SHORT"),
    3: .same(proto: "LONG"),
    4: .same(proto: "REPEAT"),
  ]
}

extension PBGui_ScreenOrientation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HORIZONTAL"),
    1: .same(proto: "HORIZONTAL_FLIP"),
    2: .same(proto: "VERTICAL"),
    3: .same(proto: "VERTICAL_FLIP"),
  ]
}

extension PBGui_ScreenFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "orientation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.orientation != .horizontal {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_ScreenFrame, rhs: PBGui_ScreenFrame) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGui_StartScreenStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartScreenStreamRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_StartScreenStreamRequest, rhs: PBGui_StartScreenStreamRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGui_StopScreenStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopScreenStreamRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_StopScreenStreamRequest, rhs: PBGui_StopScreenStreamRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGui_SendInputEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendInputEventRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != .up {
      try visitor.visitSingularEnumField(value: self.key, fieldNumber: 1)
    }
    if self.type != .press {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_SendInputEventRequest, rhs: PBGui_SendInputEventRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGui_StartVirtualDisplayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVirtualDisplayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "first_frame"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._firstFrame) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_StartVirtualDisplayRequest, rhs: PBGui_StartVirtualDisplayRequest) -> Bool {
    if lhs._firstFrame != rhs._firstFrame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBGui_StopVirtualDisplayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopVirtualDisplayRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBGui_StopVirtualDisplayRequest, rhs: PBGui_StopVirtualDisplayRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
