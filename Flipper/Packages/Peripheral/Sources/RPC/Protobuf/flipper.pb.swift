// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: flipper.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PB_CommandStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0

  ///*< Common Errors 
  case error // = 1

  ///*< Command can't be decoded successfully - command_id in response may be wrong! 
  case errorDecode // = 2

  ///*< Command succesfully decoded, but not implemented (deprecated or not yet implemented) 
  case errorNotImplemented // = 3

  ///*< Somebody took global lock, so not all commands are available 
  case errorBusy // = 4

  ///*< Not received has_next == 0 
  case errorContinuousCommandInterrupted // = 14

  ///*< not provided (or provided invalid) crucial parameters to perform rpc 
  case errorInvalidParameters // = 15

  ///*< Storage Errors 
  case errorStorageNotReady // = 5

  ///*< File/Dir alrady exist 
  case errorStorageExist // = 6

  ///*< File/Dir does not exist 
  case errorStorageNotExist // = 7

  ///*< Invalid API parameter 
  case errorStorageInvalidParameter // = 8

  ///*< Access denied 
  case errorStorageDenied // = 9

  ///*< Invalid name/path 
  case errorStorageInvalidName // = 10

  ///*< Internal error 
  case errorStorageInternal // = 11

  ///*< Functon not implemented 
  case errorStorageNotImplemented // = 12

  ///*< File/Dir already opened 
  case errorStorageAlreadyOpen // = 13

  ///*< Directory, you're going to remove is not empty 
  case errorStorageDirNotEmpty // = 18

  ///*< Application Errors 
  case errorAppCantStart // = 16

  ///*< Another app is running 
  case errorAppSystemLocked // = 17

  ///*< App is not running or doesn't support RPC commands 
  case errorAppNotRunning // = 21

  ///*< Command execution error 
  case errorAppCmdError // = 22

  ///*< Virtual Display Errors 
  case errorVirtualDisplayAlreadyStarted // = 19

  ///*< Virtual Display session can't be stopped when it's not started 
  case errorVirtualDisplayNotStarted // = 20

  ///*< GPIO Errors 
  case errorGpioModeIncorrect // = 58
  case errorGpioUnknownPinMode // = 59
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .error
    case 2: self = .errorDecode
    case 3: self = .errorNotImplemented
    case 4: self = .errorBusy
    case 5: self = .errorStorageNotReady
    case 6: self = .errorStorageExist
    case 7: self = .errorStorageNotExist
    case 8: self = .errorStorageInvalidParameter
    case 9: self = .errorStorageDenied
    case 10: self = .errorStorageInvalidName
    case 11: self = .errorStorageInternal
    case 12: self = .errorStorageNotImplemented
    case 13: self = .errorStorageAlreadyOpen
    case 14: self = .errorContinuousCommandInterrupted
    case 15: self = .errorInvalidParameters
    case 16: self = .errorAppCantStart
    case 17: self = .errorAppSystemLocked
    case 18: self = .errorStorageDirNotEmpty
    case 19: self = .errorVirtualDisplayAlreadyStarted
    case 20: self = .errorVirtualDisplayNotStarted
    case 21: self = .errorAppNotRunning
    case 22: self = .errorAppCmdError
    case 58: self = .errorGpioModeIncorrect
    case 59: self = .errorGpioUnknownPinMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .error: return 1
    case .errorDecode: return 2
    case .errorNotImplemented: return 3
    case .errorBusy: return 4
    case .errorStorageNotReady: return 5
    case .errorStorageExist: return 6
    case .errorStorageNotExist: return 7
    case .errorStorageInvalidParameter: return 8
    case .errorStorageDenied: return 9
    case .errorStorageInvalidName: return 10
    case .errorStorageInternal: return 11
    case .errorStorageNotImplemented: return 12
    case .errorStorageAlreadyOpen: return 13
    case .errorContinuousCommandInterrupted: return 14
    case .errorInvalidParameters: return 15
    case .errorAppCantStart: return 16
    case .errorAppSystemLocked: return 17
    case .errorStorageDirNotEmpty: return 18
    case .errorVirtualDisplayAlreadyStarted: return 19
    case .errorVirtualDisplayNotStarted: return 20
    case .errorAppNotRunning: return 21
    case .errorAppCmdError: return 22
    case .errorGpioModeIncorrect: return 58
    case .errorGpioUnknownPinMode: return 59
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PB_CommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PB_CommandStatus] = [
    .ok,
    .error,
    .errorDecode,
    .errorNotImplemented,
    .errorBusy,
    .errorContinuousCommandInterrupted,
    .errorInvalidParameters,
    .errorStorageNotReady,
    .errorStorageExist,
    .errorStorageNotExist,
    .errorStorageInvalidParameter,
    .errorStorageDenied,
    .errorStorageInvalidName,
    .errorStorageInternal,
    .errorStorageNotImplemented,
    .errorStorageAlreadyOpen,
    .errorStorageDirNotEmpty,
    .errorAppCantStart,
    .errorAppSystemLocked,
    .errorAppNotRunning,
    .errorAppCmdError,
    .errorVirtualDisplayAlreadyStarted,
    .errorVirtualDisplayNotStarted,
    .errorGpioModeIncorrect,
    .errorGpioUnknownPinMode,
  ]
}

#endif  // swift(>=4.2)

/// There are Server commands (e.g. Storage_write), which have no body message
/// in response. But 'oneof' obligate to have at least 1 encoded message
/// in scope. For this needs Empty message is implemented.
struct PB_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_StopSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_Main {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandID: UInt32 = 0

  var commandStatus: PB_CommandStatus = .ok

  var hasNext_p: Bool = false

  var content: PB_Main.OneOf_Content? = nil

  var empty: PB_Empty {
    get {
      if case .empty(let v)? = content {return v}
      return PB_Empty()
    }
    set {content = .empty(newValue)}
  }

  var stopSession: PB_StopSession {
    get {
      if case .stopSession(let v)? = content {return v}
      return PB_StopSession()
    }
    set {content = .stopSession(newValue)}
  }

  var systemPingRequest: PBSystem_PingRequest {
    get {
      if case .systemPingRequest(let v)? = content {return v}
      return PBSystem_PingRequest()
    }
    set {content = .systemPingRequest(newValue)}
  }

  var systemPingResponse: PBSystem_PingResponse {
    get {
      if case .systemPingResponse(let v)? = content {return v}
      return PBSystem_PingResponse()
    }
    set {content = .systemPingResponse(newValue)}
  }

  var systemRebootRequest: PBSystem_RebootRequest {
    get {
      if case .systemRebootRequest(let v)? = content {return v}
      return PBSystem_RebootRequest()
    }
    set {content = .systemRebootRequest(newValue)}
  }

  var systemDeviceInfoRequest: PBSystem_DeviceInfoRequest {
    get {
      if case .systemDeviceInfoRequest(let v)? = content {return v}
      return PBSystem_DeviceInfoRequest()
    }
    set {content = .systemDeviceInfoRequest(newValue)}
  }

  var systemDeviceInfoResponse: PBSystem_DeviceInfoResponse {
    get {
      if case .systemDeviceInfoResponse(let v)? = content {return v}
      return PBSystem_DeviceInfoResponse()
    }
    set {content = .systemDeviceInfoResponse(newValue)}
  }

  var systemFactoryResetRequest: PBSystem_FactoryResetRequest {
    get {
      if case .systemFactoryResetRequest(let v)? = content {return v}
      return PBSystem_FactoryResetRequest()
    }
    set {content = .systemFactoryResetRequest(newValue)}
  }

  var systemGetDatetimeRequest: PBSystem_GetDateTimeRequest {
    get {
      if case .systemGetDatetimeRequest(let v)? = content {return v}
      return PBSystem_GetDateTimeRequest()
    }
    set {content = .systemGetDatetimeRequest(newValue)}
  }

  var systemGetDatetimeResponse: PBSystem_GetDateTimeResponse {
    get {
      if case .systemGetDatetimeResponse(let v)? = content {return v}
      return PBSystem_GetDateTimeResponse()
    }
    set {content = .systemGetDatetimeResponse(newValue)}
  }

  var systemSetDatetimeRequest: PBSystem_SetDateTimeRequest {
    get {
      if case .systemSetDatetimeRequest(let v)? = content {return v}
      return PBSystem_SetDateTimeRequest()
    }
    set {content = .systemSetDatetimeRequest(newValue)}
  }

  var systemPlayAudiovisualAlertRequest: PBSystem_PlayAudiovisualAlertRequest {
    get {
      if case .systemPlayAudiovisualAlertRequest(let v)? = content {return v}
      return PBSystem_PlayAudiovisualAlertRequest()
    }
    set {content = .systemPlayAudiovisualAlertRequest(newValue)}
  }

  var systemProtobufVersionRequest: PBSystem_ProtobufVersionRequest {
    get {
      if case .systemProtobufVersionRequest(let v)? = content {return v}
      return PBSystem_ProtobufVersionRequest()
    }
    set {content = .systemProtobufVersionRequest(newValue)}
  }

  var systemProtobufVersionResponse: PBSystem_ProtobufVersionResponse {
    get {
      if case .systemProtobufVersionResponse(let v)? = content {return v}
      return PBSystem_ProtobufVersionResponse()
    }
    set {content = .systemProtobufVersionResponse(newValue)}
  }

  var systemUpdateRequest: PBSystem_UpdateRequest {
    get {
      if case .systemUpdateRequest(let v)? = content {return v}
      return PBSystem_UpdateRequest()
    }
    set {content = .systemUpdateRequest(newValue)}
  }

  var systemUpdateResponse: PBSystem_UpdateResponse {
    get {
      if case .systemUpdateResponse(let v)? = content {return v}
      return PBSystem_UpdateResponse()
    }
    set {content = .systemUpdateResponse(newValue)}
  }

  var systemPowerInfoRequest: PBSystem_PowerInfoRequest {
    get {
      if case .systemPowerInfoRequest(let v)? = content {return v}
      return PBSystem_PowerInfoRequest()
    }
    set {content = .systemPowerInfoRequest(newValue)}
  }

  var systemPowerInfoResponse: PBSystem_PowerInfoResponse {
    get {
      if case .systemPowerInfoResponse(let v)? = content {return v}
      return PBSystem_PowerInfoResponse()
    }
    set {content = .systemPowerInfoResponse(newValue)}
  }

  var storageInfoRequest: PBStorage_InfoRequest {
    get {
      if case .storageInfoRequest(let v)? = content {return v}
      return PBStorage_InfoRequest()
    }
    set {content = .storageInfoRequest(newValue)}
  }

  var storageInfoResponse: PBStorage_InfoResponse {
    get {
      if case .storageInfoResponse(let v)? = content {return v}
      return PBStorage_InfoResponse()
    }
    set {content = .storageInfoResponse(newValue)}
  }

  var storageTimestampRequest: PBStorage_TimestampRequest {
    get {
      if case .storageTimestampRequest(let v)? = content {return v}
      return PBStorage_TimestampRequest()
    }
    set {content = .storageTimestampRequest(newValue)}
  }

  var storageTimestampResponse: PBStorage_TimestampResponse {
    get {
      if case .storageTimestampResponse(let v)? = content {return v}
      return PBStorage_TimestampResponse()
    }
    set {content = .storageTimestampResponse(newValue)}
  }

  var storageStatRequest: PBStorage_StatRequest {
    get {
      if case .storageStatRequest(let v)? = content {return v}
      return PBStorage_StatRequest()
    }
    set {content = .storageStatRequest(newValue)}
  }

  var storageStatResponse: PBStorage_StatResponse {
    get {
      if case .storageStatResponse(let v)? = content {return v}
      return PBStorage_StatResponse()
    }
    set {content = .storageStatResponse(newValue)}
  }

  var storageListRequest: PBStorage_ListRequest {
    get {
      if case .storageListRequest(let v)? = content {return v}
      return PBStorage_ListRequest()
    }
    set {content = .storageListRequest(newValue)}
  }

  var storageListResponse: PBStorage_ListResponse {
    get {
      if case .storageListResponse(let v)? = content {return v}
      return PBStorage_ListResponse()
    }
    set {content = .storageListResponse(newValue)}
  }

  var storageReadRequest: PBStorage_ReadRequest {
    get {
      if case .storageReadRequest(let v)? = content {return v}
      return PBStorage_ReadRequest()
    }
    set {content = .storageReadRequest(newValue)}
  }

  var storageReadResponse: PBStorage_ReadResponse {
    get {
      if case .storageReadResponse(let v)? = content {return v}
      return PBStorage_ReadResponse()
    }
    set {content = .storageReadResponse(newValue)}
  }

  var storageWriteRequest: PBStorage_WriteRequest {
    get {
      if case .storageWriteRequest(let v)? = content {return v}
      return PBStorage_WriteRequest()
    }
    set {content = .storageWriteRequest(newValue)}
  }

  var storageDeleteRequest: PBStorage_DeleteRequest {
    get {
      if case .storageDeleteRequest(let v)? = content {return v}
      return PBStorage_DeleteRequest()
    }
    set {content = .storageDeleteRequest(newValue)}
  }

  var storageMkdirRequest: PBStorage_MkdirRequest {
    get {
      if case .storageMkdirRequest(let v)? = content {return v}
      return PBStorage_MkdirRequest()
    }
    set {content = .storageMkdirRequest(newValue)}
  }

  var storageMd5SumRequest: PBStorage_Md5sumRequest {
    get {
      if case .storageMd5SumRequest(let v)? = content {return v}
      return PBStorage_Md5sumRequest()
    }
    set {content = .storageMd5SumRequest(newValue)}
  }

  var storageMd5SumResponse: PBStorage_Md5sumResponse {
    get {
      if case .storageMd5SumResponse(let v)? = content {return v}
      return PBStorage_Md5sumResponse()
    }
    set {content = .storageMd5SumResponse(newValue)}
  }

  var storageRenameRequest: PBStorage_RenameRequest {
    get {
      if case .storageRenameRequest(let v)? = content {return v}
      return PBStorage_RenameRequest()
    }
    set {content = .storageRenameRequest(newValue)}
  }

  var storageBackupCreateRequest: PBStorage_BackupCreateRequest {
    get {
      if case .storageBackupCreateRequest(let v)? = content {return v}
      return PBStorage_BackupCreateRequest()
    }
    set {content = .storageBackupCreateRequest(newValue)}
  }

  var storageBackupRestoreRequest: PBStorage_BackupRestoreRequest {
    get {
      if case .storageBackupRestoreRequest(let v)? = content {return v}
      return PBStorage_BackupRestoreRequest()
    }
    set {content = .storageBackupRestoreRequest(newValue)}
  }

  var appStartRequest: PBApp_StartRequest {
    get {
      if case .appStartRequest(let v)? = content {return v}
      return PBApp_StartRequest()
    }
    set {content = .appStartRequest(newValue)}
  }

  var appLockStatusRequest: PBApp_LockStatusRequest {
    get {
      if case .appLockStatusRequest(let v)? = content {return v}
      return PBApp_LockStatusRequest()
    }
    set {content = .appLockStatusRequest(newValue)}
  }

  var appLockStatusResponse: PBApp_LockStatusResponse {
    get {
      if case .appLockStatusResponse(let v)? = content {return v}
      return PBApp_LockStatusResponse()
    }
    set {content = .appLockStatusResponse(newValue)}
  }

  var appExitRequest: PBApp_AppExitRequest {
    get {
      if case .appExitRequest(let v)? = content {return v}
      return PBApp_AppExitRequest()
    }
    set {content = .appExitRequest(newValue)}
  }

  var appLoadFileRequest: PBApp_AppLoadFileRequest {
    get {
      if case .appLoadFileRequest(let v)? = content {return v}
      return PBApp_AppLoadFileRequest()
    }
    set {content = .appLoadFileRequest(newValue)}
  }

  var appButtonPressRequest: PBApp_AppButtonPressRequest {
    get {
      if case .appButtonPressRequest(let v)? = content {return v}
      return PBApp_AppButtonPressRequest()
    }
    set {content = .appButtonPressRequest(newValue)}
  }

  var appButtonReleaseRequest: PBApp_AppButtonReleaseRequest {
    get {
      if case .appButtonReleaseRequest(let v)? = content {return v}
      return PBApp_AppButtonReleaseRequest()
    }
    set {content = .appButtonReleaseRequest(newValue)}
  }

  var appGetErrorRequest: PBApp_GetErrorRequest {
    get {
      if case .appGetErrorRequest(let v)? = content {return v}
      return PBApp_GetErrorRequest()
    }
    set {content = .appGetErrorRequest(newValue)}
  }

  var appGetErrorResponse: PBApp_GetErrorResponse {
    get {
      if case .appGetErrorResponse(let v)? = content {return v}
      return PBApp_GetErrorResponse()
    }
    set {content = .appGetErrorResponse(newValue)}
  }

  var appDataExchangeRequest: PBApp_DataExchangeRequest {
    get {
      if case .appDataExchangeRequest(let v)? = content {return v}
      return PBApp_DataExchangeRequest()
    }
    set {content = .appDataExchangeRequest(newValue)}
  }

  var guiStartScreenStreamRequest: PBGui_StartScreenStreamRequest {
    get {
      if case .guiStartScreenStreamRequest(let v)? = content {return v}
      return PBGui_StartScreenStreamRequest()
    }
    set {content = .guiStartScreenStreamRequest(newValue)}
  }

  var guiStopScreenStreamRequest: PBGui_StopScreenStreamRequest {
    get {
      if case .guiStopScreenStreamRequest(let v)? = content {return v}
      return PBGui_StopScreenStreamRequest()
    }
    set {content = .guiStopScreenStreamRequest(newValue)}
  }

  var guiScreenFrame: PBGui_ScreenFrame {
    get {
      if case .guiScreenFrame(let v)? = content {return v}
      return PBGui_ScreenFrame()
    }
    set {content = .guiScreenFrame(newValue)}
  }

  var guiSendInputEventRequest: PBGui_SendInputEventRequest {
    get {
      if case .guiSendInputEventRequest(let v)? = content {return v}
      return PBGui_SendInputEventRequest()
    }
    set {content = .guiSendInputEventRequest(newValue)}
  }

  var guiStartVirtualDisplayRequest: PBGui_StartVirtualDisplayRequest {
    get {
      if case .guiStartVirtualDisplayRequest(let v)? = content {return v}
      return PBGui_StartVirtualDisplayRequest()
    }
    set {content = .guiStartVirtualDisplayRequest(newValue)}
  }

  var guiStopVirtualDisplayRequest: PBGui_StopVirtualDisplayRequest {
    get {
      if case .guiStopVirtualDisplayRequest(let v)? = content {return v}
      return PBGui_StopVirtualDisplayRequest()
    }
    set {content = .guiStopVirtualDisplayRequest(newValue)}
  }

  var gpioSetPinMode: PBGpio_SetPinMode {
    get {
      if case .gpioSetPinMode(let v)? = content {return v}
      return PBGpio_SetPinMode()
    }
    set {content = .gpioSetPinMode(newValue)}
  }

  var gpioSetInputPull: PBGpio_SetInputPull {
    get {
      if case .gpioSetInputPull(let v)? = content {return v}
      return PBGpio_SetInputPull()
    }
    set {content = .gpioSetInputPull(newValue)}
  }

  var gpioGetPinMode: PBGpio_GetPinMode {
    get {
      if case .gpioGetPinMode(let v)? = content {return v}
      return PBGpio_GetPinMode()
    }
    set {content = .gpioGetPinMode(newValue)}
  }

  var gpioGetPinModeResponse: PBGpio_GetPinModeResponse {
    get {
      if case .gpioGetPinModeResponse(let v)? = content {return v}
      return PBGpio_GetPinModeResponse()
    }
    set {content = .gpioGetPinModeResponse(newValue)}
  }

  var gpioReadPin: PBGpio_ReadPin {
    get {
      if case .gpioReadPin(let v)? = content {return v}
      return PBGpio_ReadPin()
    }
    set {content = .gpioReadPin(newValue)}
  }

  var gpioReadPinResponse: PBGpio_ReadPinResponse {
    get {
      if case .gpioReadPinResponse(let v)? = content {return v}
      return PBGpio_ReadPinResponse()
    }
    set {content = .gpioReadPinResponse(newValue)}
  }

  var gpioWritePin: PBGpio_WritePin {
    get {
      if case .gpioWritePin(let v)? = content {return v}
      return PBGpio_WritePin()
    }
    set {content = .gpioWritePin(newValue)}
  }

  var appStateResponse: PBApp_AppStateResponse {
    get {
      if case .appStateResponse(let v)? = content {return v}
      return PBApp_AppStateResponse()
    }
    set {content = .appStateResponse(newValue)}
  }

  var propertyGetRequest: PBProperty_GetRequest {
    get {
      if case .propertyGetRequest(let v)? = content {return v}
      return PBProperty_GetRequest()
    }
    set {content = .propertyGetRequest(newValue)}
  }

  var propertyGetResponse: PBProperty_GetResponse {
    get {
      if case .propertyGetResponse(let v)? = content {return v}
      return PBProperty_GetResponse()
    }
    set {content = .propertyGetResponse(newValue)}
  }

  var desktopIsLockedRequest: PBDesktop_IsLockedRequest {
    get {
      if case .desktopIsLockedRequest(let v)? = content {return v}
      return PBDesktop_IsLockedRequest()
    }
    set {content = .desktopIsLockedRequest(newValue)}
  }

  var desktopUnlockRequest: PBDesktop_UnlockRequest {
    get {
      if case .desktopUnlockRequest(let v)? = content {return v}
      return PBDesktop_UnlockRequest()
    }
    set {content = .desktopUnlockRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case empty(PB_Empty)
    case stopSession(PB_StopSession)
    case systemPingRequest(PBSystem_PingRequest)
    case systemPingResponse(PBSystem_PingResponse)
    case systemRebootRequest(PBSystem_RebootRequest)
    case systemDeviceInfoRequest(PBSystem_DeviceInfoRequest)
    case systemDeviceInfoResponse(PBSystem_DeviceInfoResponse)
    case systemFactoryResetRequest(PBSystem_FactoryResetRequest)
    case systemGetDatetimeRequest(PBSystem_GetDateTimeRequest)
    case systemGetDatetimeResponse(PBSystem_GetDateTimeResponse)
    case systemSetDatetimeRequest(PBSystem_SetDateTimeRequest)
    case systemPlayAudiovisualAlertRequest(PBSystem_PlayAudiovisualAlertRequest)
    case systemProtobufVersionRequest(PBSystem_ProtobufVersionRequest)
    case systemProtobufVersionResponse(PBSystem_ProtobufVersionResponse)
    case systemUpdateRequest(PBSystem_UpdateRequest)
    case systemUpdateResponse(PBSystem_UpdateResponse)
    case systemPowerInfoRequest(PBSystem_PowerInfoRequest)
    case systemPowerInfoResponse(PBSystem_PowerInfoResponse)
    case storageInfoRequest(PBStorage_InfoRequest)
    case storageInfoResponse(PBStorage_InfoResponse)
    case storageTimestampRequest(PBStorage_TimestampRequest)
    case storageTimestampResponse(PBStorage_TimestampResponse)
    case storageStatRequest(PBStorage_StatRequest)
    case storageStatResponse(PBStorage_StatResponse)
    case storageListRequest(PBStorage_ListRequest)
    case storageListResponse(PBStorage_ListResponse)
    case storageReadRequest(PBStorage_ReadRequest)
    case storageReadResponse(PBStorage_ReadResponse)
    case storageWriteRequest(PBStorage_WriteRequest)
    case storageDeleteRequest(PBStorage_DeleteRequest)
    case storageMkdirRequest(PBStorage_MkdirRequest)
    case storageMd5SumRequest(PBStorage_Md5sumRequest)
    case storageMd5SumResponse(PBStorage_Md5sumResponse)
    case storageRenameRequest(PBStorage_RenameRequest)
    case storageBackupCreateRequest(PBStorage_BackupCreateRequest)
    case storageBackupRestoreRequest(PBStorage_BackupRestoreRequest)
    case appStartRequest(PBApp_StartRequest)
    case appLockStatusRequest(PBApp_LockStatusRequest)
    case appLockStatusResponse(PBApp_LockStatusResponse)
    case appExitRequest(PBApp_AppExitRequest)
    case appLoadFileRequest(PBApp_AppLoadFileRequest)
    case appButtonPressRequest(PBApp_AppButtonPressRequest)
    case appButtonReleaseRequest(PBApp_AppButtonReleaseRequest)
    case appGetErrorRequest(PBApp_GetErrorRequest)
    case appGetErrorResponse(PBApp_GetErrorResponse)
    case appDataExchangeRequest(PBApp_DataExchangeRequest)
    case guiStartScreenStreamRequest(PBGui_StartScreenStreamRequest)
    case guiStopScreenStreamRequest(PBGui_StopScreenStreamRequest)
    case guiScreenFrame(PBGui_ScreenFrame)
    case guiSendInputEventRequest(PBGui_SendInputEventRequest)
    case guiStartVirtualDisplayRequest(PBGui_StartVirtualDisplayRequest)
    case guiStopVirtualDisplayRequest(PBGui_StopVirtualDisplayRequest)
    case gpioSetPinMode(PBGpio_SetPinMode)
    case gpioSetInputPull(PBGpio_SetInputPull)
    case gpioGetPinMode(PBGpio_GetPinMode)
    case gpioGetPinModeResponse(PBGpio_GetPinModeResponse)
    case gpioReadPin(PBGpio_ReadPin)
    case gpioReadPinResponse(PBGpio_ReadPinResponse)
    case gpioWritePin(PBGpio_WritePin)
    case appStateResponse(PBApp_AppStateResponse)
    case propertyGetRequest(PBProperty_GetRequest)
    case propertyGetResponse(PBProperty_GetResponse)
    case desktopIsLockedRequest(PBDesktop_IsLockedRequest)
    case desktopUnlockRequest(PBDesktop_UnlockRequest)

  #if !swift(>=4.1)
    static func ==(lhs: PB_Main.OneOf_Content, rhs: PB_Main.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopSession, .stopSession): return {
        guard case .stopSession(let l) = lhs, case .stopSession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPingRequest, .systemPingRequest): return {
        guard case .systemPingRequest(let l) = lhs, case .systemPingRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPingResponse, .systemPingResponse): return {
        guard case .systemPingResponse(let l) = lhs, case .systemPingResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemRebootRequest, .systemRebootRequest): return {
        guard case .systemRebootRequest(let l) = lhs, case .systemRebootRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemDeviceInfoRequest, .systemDeviceInfoRequest): return {
        guard case .systemDeviceInfoRequest(let l) = lhs, case .systemDeviceInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemDeviceInfoResponse, .systemDeviceInfoResponse): return {
        guard case .systemDeviceInfoResponse(let l) = lhs, case .systemDeviceInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemFactoryResetRequest, .systemFactoryResetRequest): return {
        guard case .systemFactoryResetRequest(let l) = lhs, case .systemFactoryResetRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemGetDatetimeRequest, .systemGetDatetimeRequest): return {
        guard case .systemGetDatetimeRequest(let l) = lhs, case .systemGetDatetimeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemGetDatetimeResponse, .systemGetDatetimeResponse): return {
        guard case .systemGetDatetimeResponse(let l) = lhs, case .systemGetDatetimeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemSetDatetimeRequest, .systemSetDatetimeRequest): return {
        guard case .systemSetDatetimeRequest(let l) = lhs, case .systemSetDatetimeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPlayAudiovisualAlertRequest, .systemPlayAudiovisualAlertRequest): return {
        guard case .systemPlayAudiovisualAlertRequest(let l) = lhs, case .systemPlayAudiovisualAlertRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemProtobufVersionRequest, .systemProtobufVersionRequest): return {
        guard case .systemProtobufVersionRequest(let l) = lhs, case .systemProtobufVersionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemProtobufVersionResponse, .systemProtobufVersionResponse): return {
        guard case .systemProtobufVersionResponse(let l) = lhs, case .systemProtobufVersionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemUpdateRequest, .systemUpdateRequest): return {
        guard case .systemUpdateRequest(let l) = lhs, case .systemUpdateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemUpdateResponse, .systemUpdateResponse): return {
        guard case .systemUpdateResponse(let l) = lhs, case .systemUpdateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPowerInfoRequest, .systemPowerInfoRequest): return {
        guard case .systemPowerInfoRequest(let l) = lhs, case .systemPowerInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPowerInfoResponse, .systemPowerInfoResponse): return {
        guard case .systemPowerInfoResponse(let l) = lhs, case .systemPowerInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageInfoRequest, .storageInfoRequest): return {
        guard case .storageInfoRequest(let l) = lhs, case .storageInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageInfoResponse, .storageInfoResponse): return {
        guard case .storageInfoResponse(let l) = lhs, case .storageInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageTimestampRequest, .storageTimestampRequest): return {
        guard case .storageTimestampRequest(let l) = lhs, case .storageTimestampRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageTimestampResponse, .storageTimestampResponse): return {
        guard case .storageTimestampResponse(let l) = lhs, case .storageTimestampResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageStatRequest, .storageStatRequest): return {
        guard case .storageStatRequest(let l) = lhs, case .storageStatRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageStatResponse, .storageStatResponse): return {
        guard case .storageStatResponse(let l) = lhs, case .storageStatResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListRequest, .storageListRequest): return {
        guard case .storageListRequest(let l) = lhs, case .storageListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListResponse, .storageListResponse): return {
        guard case .storageListResponse(let l) = lhs, case .storageListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadRequest, .storageReadRequest): return {
        guard case .storageReadRequest(let l) = lhs, case .storageReadRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadResponse, .storageReadResponse): return {
        guard case .storageReadResponse(let l) = lhs, case .storageReadResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageWriteRequest, .storageWriteRequest): return {
        guard case .storageWriteRequest(let l) = lhs, case .storageWriteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageDeleteRequest, .storageDeleteRequest): return {
        guard case .storageDeleteRequest(let l) = lhs, case .storageDeleteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMkdirRequest, .storageMkdirRequest): return {
        guard case .storageMkdirRequest(let l) = lhs, case .storageMkdirRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumRequest, .storageMd5SumRequest): return {
        guard case .storageMd5SumRequest(let l) = lhs, case .storageMd5SumRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumResponse, .storageMd5SumResponse): return {
        guard case .storageMd5SumResponse(let l) = lhs, case .storageMd5SumResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageRenameRequest, .storageRenameRequest): return {
        guard case .storageRenameRequest(let l) = lhs, case .storageRenameRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageBackupCreateRequest, .storageBackupCreateRequest): return {
        guard case .storageBackupCreateRequest(let l) = lhs, case .storageBackupCreateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageBackupRestoreRequest, .storageBackupRestoreRequest): return {
        guard case .storageBackupRestoreRequest(let l) = lhs, case .storageBackupRestoreRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appStartRequest, .appStartRequest): return {
        guard case .appStartRequest(let l) = lhs, case .appStartRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appLockStatusRequest, .appLockStatusRequest): return {
        guard case .appLockStatusRequest(let l) = lhs, case .appLockStatusRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appLockStatusResponse, .appLockStatusResponse): return {
        guard case .appLockStatusResponse(let l) = lhs, case .appLockStatusResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appExitRequest, .appExitRequest): return {
        guard case .appExitRequest(let l) = lhs, case .appExitRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appLoadFileRequest, .appLoadFileRequest): return {
        guard case .appLoadFileRequest(let l) = lhs, case .appLoadFileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appButtonPressRequest, .appButtonPressRequest): return {
        guard case .appButtonPressRequest(let l) = lhs, case .appButtonPressRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appButtonReleaseRequest, .appButtonReleaseRequest): return {
        guard case .appButtonReleaseRequest(let l) = lhs, case .appButtonReleaseRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appGetErrorRequest, .appGetErrorRequest): return {
        guard case .appGetErrorRequest(let l) = lhs, case .appGetErrorRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appGetErrorResponse, .appGetErrorResponse): return {
        guard case .appGetErrorResponse(let l) = lhs, case .appGetErrorResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDataExchangeRequest, .appDataExchangeRequest): return {
        guard case .appDataExchangeRequest(let l) = lhs, case .appDataExchangeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStartScreenStreamRequest, .guiStartScreenStreamRequest): return {
        guard case .guiStartScreenStreamRequest(let l) = lhs, case .guiStartScreenStreamRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStopScreenStreamRequest, .guiStopScreenStreamRequest): return {
        guard case .guiStopScreenStreamRequest(let l) = lhs, case .guiStopScreenStreamRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiScreenFrame, .guiScreenFrame): return {
        guard case .guiScreenFrame(let l) = lhs, case .guiScreenFrame(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiSendInputEventRequest, .guiSendInputEventRequest): return {
        guard case .guiSendInputEventRequest(let l) = lhs, case .guiSendInputEventRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStartVirtualDisplayRequest, .guiStartVirtualDisplayRequest): return {
        guard case .guiStartVirtualDisplayRequest(let l) = lhs, case .guiStartVirtualDisplayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStopVirtualDisplayRequest, .guiStopVirtualDisplayRequest): return {
        guard case .guiStopVirtualDisplayRequest(let l) = lhs, case .guiStopVirtualDisplayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioSetPinMode, .gpioSetPinMode): return {
        guard case .gpioSetPinMode(let l) = lhs, case .gpioSetPinMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioSetInputPull, .gpioSetInputPull): return {
        guard case .gpioSetInputPull(let l) = lhs, case .gpioSetInputPull(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioGetPinMode, .gpioGetPinMode): return {
        guard case .gpioGetPinMode(let l) = lhs, case .gpioGetPinMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioGetPinModeResponse, .gpioGetPinModeResponse): return {
        guard case .gpioGetPinModeResponse(let l) = lhs, case .gpioGetPinModeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioReadPin, .gpioReadPin): return {
        guard case .gpioReadPin(let l) = lhs, case .gpioReadPin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioReadPinResponse, .gpioReadPinResponse): return {
        guard case .gpioReadPinResponse(let l) = lhs, case .gpioReadPinResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpioWritePin, .gpioWritePin): return {
        guard case .gpioWritePin(let l) = lhs, case .gpioWritePin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appStateResponse, .appStateResponse): return {
        guard case .appStateResponse(let l) = lhs, case .appStateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.propertyGetRequest, .propertyGetRequest): return {
        guard case .propertyGetRequest(let l) = lhs, case .propertyGetRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.propertyGetResponse, .propertyGetResponse): return {
        guard case .propertyGetResponse(let l) = lhs, case .propertyGetResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopIsLockedRequest, .desktopIsLockedRequest): return {
        guard case .desktopIsLockedRequest(let l) = lhs, case .desktopIsLockedRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopUnlockRequest, .desktopUnlockRequest): return {
        guard case .desktopUnlockRequest(let l) = lhs, case .desktopUnlockRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PB_Region {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: Data = Data()

  var bands: [PB_Region.Band] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Band {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var start: UInt32 = 0

    var end: UInt32 = 0

    var powerLimit: Int32 = 0

    var dutyCycle: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PB_CommandStatus: @unchecked Sendable {}
extension PB_Empty: @unchecked Sendable {}
extension PB_StopSession: @unchecked Sendable {}
extension PB_Main: @unchecked Sendable {}
extension PB_Main.OneOf_Content: @unchecked Sendable {}
extension PB_Region: @unchecked Sendable {}
extension PB_Region.Band: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB"

extension PB_CommandStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "ERROR_DECODE"),
    3: .same(proto: "ERROR_NOT_IMPLEMENTED"),
    4: .same(proto: "ERROR_BUSY"),
    5: .same(proto: "ERROR_STORAGE_NOT_READY"),
    6: .same(proto: "ERROR_STORAGE_EXIST"),
    7: .same(proto: "ERROR_STORAGE_NOT_EXIST"),
    8: .same(proto: "ERROR_STORAGE_INVALID_PARAMETER"),
    9: .same(proto: "ERROR_STORAGE_DENIED"),
    10: .same(proto: "ERROR_STORAGE_INVALID_NAME"),
    11: .same(proto: "ERROR_STORAGE_INTERNAL"),
    12: .same(proto: "ERROR_STORAGE_NOT_IMPLEMENTED"),
    13: .same(proto: "ERROR_STORAGE_ALREADY_OPEN"),
    14: .same(proto: "ERROR_CONTINUOUS_COMMAND_INTERRUPTED"),
    15: .same(proto: "ERROR_INVALID_PARAMETERS"),
    16: .same(proto: "ERROR_APP_CANT_START"),
    17: .same(proto: "ERROR_APP_SYSTEM_LOCKED"),
    18: .same(proto: "ERROR_STORAGE_DIR_NOT_EMPTY"),
    19: .same(proto: "ERROR_VIRTUAL_DISPLAY_ALREADY_STARTED"),
    20: .same(proto: "ERROR_VIRTUAL_DISPLAY_NOT_STARTED"),
    21: .same(proto: "ERROR_APP_NOT_RUNNING"),
    22: .same(proto: "ERROR_APP_CMD_ERROR"),
    58: .same(proto: "ERROR_GPIO_MODE_INCORRECT"),
    59: .same(proto: "ERROR_GPIO_UNKNOWN_PIN_MODE"),
  ]
}

extension PB_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Empty, rhs: PB_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_StopSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopSession"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_StopSession, rhs: PB_StopSession) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Main: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Main"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "command_status"),
    3: .standard(proto: "has_next"),
    4: .same(proto: "empty"),
    19: .standard(proto: "stop_session"),
    5: .standard(proto: "system_ping_request"),
    6: .standard(proto: "system_ping_response"),
    31: .standard(proto: "system_reboot_request"),
    32: .standard(proto: "system_device_info_request"),
    33: .standard(proto: "system_device_info_response"),
    34: .standard(proto: "system_factory_reset_request"),
    35: .standard(proto: "system_get_datetime_request"),
    36: .standard(proto: "system_get_datetime_response"),
    37: .standard(proto: "system_set_datetime_request"),
    38: .standard(proto: "system_play_audiovisual_alert_request"),
    39: .standard(proto: "system_protobuf_version_request"),
    40: .standard(proto: "system_protobuf_version_response"),
    41: .standard(proto: "system_update_request"),
    46: .standard(proto: "system_update_response"),
    44: .standard(proto: "system_power_info_request"),
    45: .standard(proto: "system_power_info_response"),
    28: .standard(proto: "storage_info_request"),
    29: .standard(proto: "storage_info_response"),
    59: .standard(proto: "storage_timestamp_request"),
    60: .standard(proto: "storage_timestamp_response"),
    24: .standard(proto: "storage_stat_request"),
    25: .standard(proto: "storage_stat_response"),
    7: .standard(proto: "storage_list_request"),
    8: .standard(proto: "storage_list_response"),
    9: .standard(proto: "storage_read_request"),
    10: .standard(proto: "storage_read_response"),
    11: .standard(proto: "storage_write_request"),
    12: .standard(proto: "storage_delete_request"),
    13: .standard(proto: "storage_mkdir_request"),
    14: .standard(proto: "storage_md5sum_request"),
    15: .standard(proto: "storage_md5sum_response"),
    30: .standard(proto: "storage_rename_request"),
    42: .standard(proto: "storage_backup_create_request"),
    43: .standard(proto: "storage_backup_restore_request"),
    16: .standard(proto: "app_start_request"),
    17: .standard(proto: "app_lock_status_request"),
    18: .standard(proto: "app_lock_status_response"),
    47: .standard(proto: "app_exit_request"),
    48: .standard(proto: "app_load_file_request"),
    49: .standard(proto: "app_button_press_request"),
    50: .standard(proto: "app_button_release_request"),
    63: .standard(proto: "app_get_error_request"),
    64: .standard(proto: "app_get_error_response"),
    65: .standard(proto: "app_data_exchange_request"),
    20: .standard(proto: "gui_start_screen_stream_request"),
    21: .standard(proto: "gui_stop_screen_stream_request"),
    22: .standard(proto: "gui_screen_frame"),
    23: .standard(proto: "gui_send_input_event_request"),
    26: .standard(proto: "gui_start_virtual_display_request"),
    27: .standard(proto: "gui_stop_virtual_display_request"),
    51: .standard(proto: "gpio_set_pin_mode"),
    52: .standard(proto: "gpio_set_input_pull"),
    53: .standard(proto: "gpio_get_pin_mode"),
    54: .standard(proto: "gpio_get_pin_mode_response"),
    55: .standard(proto: "gpio_read_pin"),
    56: .standard(proto: "gpio_read_pin_response"),
    57: .standard(proto: "gpio_write_pin"),
    58: .standard(proto: "app_state_response"),
    61: .standard(proto: "property_get_request"),
    62: .standard(proto: "property_get_response"),
    66: .standard(proto: "desktop_is_locked_request"),
    67: .standard(proto: "desktop_unlock_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.commandID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.commandStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 4: try {
        var v: PB_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .empty(v)
        }
      }()
      case 5: try {
        var v: PBSystem_PingRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemPingRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemPingRequest(v)
        }
      }()
      case 6: try {
        var v: PBSystem_PingResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemPingResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemPingResponse(v)
        }
      }()
      case 7: try {
        var v: PBStorage_ListRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListRequest(v)
        }
      }()
      case 8: try {
        var v: PBStorage_ListResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListResponse(v)
        }
      }()
      case 9: try {
        var v: PBStorage_ReadRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadRequest(v)
        }
      }()
      case 10: try {
        var v: PBStorage_ReadResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadResponse(v)
        }
      }()
      case 11: try {
        var v: PBStorage_WriteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageWriteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageWriteRequest(v)
        }
      }()
      case 12: try {
        var v: PBStorage_DeleteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageDeleteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageDeleteRequest(v)
        }
      }()
      case 13: try {
        var v: PBStorage_MkdirRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMkdirRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMkdirRequest(v)
        }
      }()
      case 14: try {
        var v: PBStorage_Md5sumRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumRequest(v)
        }
      }()
      case 15: try {
        var v: PBStorage_Md5sumResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumResponse(v)
        }
      }()
      case 16: try {
        var v: PBApp_StartRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appStartRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appStartRequest(v)
        }
      }()
      case 17: try {
        var v: PBApp_LockStatusRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appLockStatusRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appLockStatusRequest(v)
        }
      }()
      case 18: try {
        var v: PBApp_LockStatusResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appLockStatusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appLockStatusResponse(v)
        }
      }()
      case 19: try {
        var v: PB_StopSession?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .stopSession(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .stopSession(v)
        }
      }()
      case 20: try {
        var v: PBGui_StartScreenStreamRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStartScreenStreamRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStartScreenStreamRequest(v)
        }
      }()
      case 21: try {
        var v: PBGui_StopScreenStreamRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStopScreenStreamRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStopScreenStreamRequest(v)
        }
      }()
      case 22: try {
        var v: PBGui_ScreenFrame?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiScreenFrame(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiScreenFrame(v)
        }
      }()
      case 23: try {
        var v: PBGui_SendInputEventRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiSendInputEventRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiSendInputEventRequest(v)
        }
      }()
      case 24: try {
        var v: PBStorage_StatRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageStatRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageStatRequest(v)
        }
      }()
      case 25: try {
        var v: PBStorage_StatResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageStatResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageStatResponse(v)
        }
      }()
      case 26: try {
        var v: PBGui_StartVirtualDisplayRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStartVirtualDisplayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStartVirtualDisplayRequest(v)
        }
      }()
      case 27: try {
        var v: PBGui_StopVirtualDisplayRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStopVirtualDisplayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStopVirtualDisplayRequest(v)
        }
      }()
      case 28: try {
        var v: PBStorage_InfoRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageInfoRequest(v)
        }
      }()
      case 29: try {
        var v: PBStorage_InfoResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageInfoResponse(v)
        }
      }()
      case 30: try {
        var v: PBStorage_RenameRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageRenameRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageRenameRequest(v)
        }
      }()
      case 31: try {
        var v: PBSystem_RebootRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemRebootRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemRebootRequest(v)
        }
      }()
      case 32: try {
        var v: PBSystem_DeviceInfoRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemDeviceInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemDeviceInfoRequest(v)
        }
      }()
      case 33: try {
        var v: PBSystem_DeviceInfoResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemDeviceInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemDeviceInfoResponse(v)
        }
      }()
      case 34: try {
        var v: PBSystem_FactoryResetRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemFactoryResetRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemFactoryResetRequest(v)
        }
      }()
      case 35: try {
        var v: PBSystem_GetDateTimeRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemGetDatetimeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemGetDatetimeRequest(v)
        }
      }()
      case 36: try {
        var v: PBSystem_GetDateTimeResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemGetDatetimeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemGetDatetimeResponse(v)
        }
      }()
      case 37: try {
        var v: PBSystem_SetDateTimeRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemSetDatetimeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemSetDatetimeRequest(v)
        }
      }()
      case 38: try {
        var v: PBSystem_PlayAudiovisualAlertRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemPlayAudiovisualAlertRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemPlayAudiovisualAlertRequest(v)
        }
      }()
      case 39: try {
        var v: PBSystem_ProtobufVersionRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemProtobufVersionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemProtobufVersionRequest(v)
        }
      }()
      case 40: try {
        var v: PBSystem_ProtobufVersionResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemProtobufVersionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemProtobufVersionResponse(v)
        }
      }()
      case 41: try {
        var v: PBSystem_UpdateRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemUpdateRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemUpdateRequest(v)
        }
      }()
      case 42: try {
        var v: PBStorage_BackupCreateRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageBackupCreateRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageBackupCreateRequest(v)
        }
      }()
      case 43: try {
        var v: PBStorage_BackupRestoreRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageBackupRestoreRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageBackupRestoreRequest(v)
        }
      }()
      case 44: try {
        var v: PBSystem_PowerInfoRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemPowerInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemPowerInfoRequest(v)
        }
      }()
      case 45: try {
        var v: PBSystem_PowerInfoResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemPowerInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemPowerInfoResponse(v)
        }
      }()
      case 46: try {
        var v: PBSystem_UpdateResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .systemUpdateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .systemUpdateResponse(v)
        }
      }()
      case 47: try {
        var v: PBApp_AppExitRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appExitRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appExitRequest(v)
        }
      }()
      case 48: try {
        var v: PBApp_AppLoadFileRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appLoadFileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appLoadFileRequest(v)
        }
      }()
      case 49: try {
        var v: PBApp_AppButtonPressRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appButtonPressRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appButtonPressRequest(v)
        }
      }()
      case 50: try {
        var v: PBApp_AppButtonReleaseRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appButtonReleaseRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appButtonReleaseRequest(v)
        }
      }()
      case 51: try {
        var v: PBGpio_SetPinMode?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioSetPinMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioSetPinMode(v)
        }
      }()
      case 52: try {
        var v: PBGpio_SetInputPull?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioSetInputPull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioSetInputPull(v)
        }
      }()
      case 53: try {
        var v: PBGpio_GetPinMode?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioGetPinMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioGetPinMode(v)
        }
      }()
      case 54: try {
        var v: PBGpio_GetPinModeResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioGetPinModeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioGetPinModeResponse(v)
        }
      }()
      case 55: try {
        var v: PBGpio_ReadPin?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioReadPin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioReadPin(v)
        }
      }()
      case 56: try {
        var v: PBGpio_ReadPinResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioReadPinResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioReadPinResponse(v)
        }
      }()
      case 57: try {
        var v: PBGpio_WritePin?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .gpioWritePin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .gpioWritePin(v)
        }
      }()
      case 58: try {
        var v: PBApp_AppStateResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appStateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appStateResponse(v)
        }
      }()
      case 59: try {
        var v: PBStorage_TimestampRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageTimestampRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageTimestampRequest(v)
        }
      }()
      case 60: try {
        var v: PBStorage_TimestampResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageTimestampResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageTimestampResponse(v)
        }
      }()
      case 61: try {
        var v: PBProperty_GetRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .propertyGetRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .propertyGetRequest(v)
        }
      }()
      case 62: try {
        var v: PBProperty_GetResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .propertyGetResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .propertyGetResponse(v)
        }
      }()
      case 63: try {
        var v: PBApp_GetErrorRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appGetErrorRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appGetErrorRequest(v)
        }
      }()
      case 64: try {
        var v: PBApp_GetErrorResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appGetErrorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appGetErrorResponse(v)
        }
      }()
      case 65: try {
        var v: PBApp_DataExchangeRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appDataExchangeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appDataExchangeRequest(v)
        }
      }()
      case 66: try {
        var v: PBDesktop_IsLockedRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .desktopIsLockedRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .desktopIsLockedRequest(v)
        }
      }()
      case 67: try {
        var v: PBDesktop_UnlockRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .desktopUnlockRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .desktopUnlockRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 1)
    }
    if self.commandStatus != .ok {
      try visitor.visitSingularEnumField(value: self.commandStatus, fieldNumber: 2)
    }
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 3)
    }
    switch self.content {
    case .empty?: try {
      guard case .empty(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .systemPingRequest?: try {
      guard case .systemPingRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .systemPingResponse?: try {
      guard case .systemPingResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .storageListRequest?: try {
      guard case .storageListRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .storageListResponse?: try {
      guard case .storageListResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .storageReadRequest?: try {
      guard case .storageReadRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .storageReadResponse?: try {
      guard case .storageReadResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .storageWriteRequest?: try {
      guard case .storageWriteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .storageDeleteRequest?: try {
      guard case .storageDeleteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .storageMkdirRequest?: try {
      guard case .storageMkdirRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .storageMd5SumRequest?: try {
      guard case .storageMd5SumRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .storageMd5SumResponse?: try {
      guard case .storageMd5SumResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .appStartRequest?: try {
      guard case .appStartRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .appLockStatusRequest?: try {
      guard case .appLockStatusRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .appLockStatusResponse?: try {
      guard case .appLockStatusResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .stopSession?: try {
      guard case .stopSession(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .guiStartScreenStreamRequest?: try {
      guard case .guiStartScreenStreamRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .guiStopScreenStreamRequest?: try {
      guard case .guiStopScreenStreamRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .guiScreenFrame?: try {
      guard case .guiScreenFrame(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .guiSendInputEventRequest?: try {
      guard case .guiSendInputEventRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .storageStatRequest?: try {
      guard case .storageStatRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .storageStatResponse?: try {
      guard case .storageStatResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .guiStartVirtualDisplayRequest?: try {
      guard case .guiStartVirtualDisplayRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .guiStopVirtualDisplayRequest?: try {
      guard case .guiStopVirtualDisplayRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .storageInfoRequest?: try {
      guard case .storageInfoRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .storageInfoResponse?: try {
      guard case .storageInfoResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .storageRenameRequest?: try {
      guard case .storageRenameRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .systemRebootRequest?: try {
      guard case .systemRebootRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .systemDeviceInfoRequest?: try {
      guard case .systemDeviceInfoRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .systemDeviceInfoResponse?: try {
      guard case .systemDeviceInfoResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .systemFactoryResetRequest?: try {
      guard case .systemFactoryResetRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .systemGetDatetimeRequest?: try {
      guard case .systemGetDatetimeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .systemGetDatetimeResponse?: try {
      guard case .systemGetDatetimeResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .systemSetDatetimeRequest?: try {
      guard case .systemSetDatetimeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .systemPlayAudiovisualAlertRequest?: try {
      guard case .systemPlayAudiovisualAlertRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .systemProtobufVersionRequest?: try {
      guard case .systemProtobufVersionRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .systemProtobufVersionResponse?: try {
      guard case .systemProtobufVersionResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .systemUpdateRequest?: try {
      guard case .systemUpdateRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .storageBackupCreateRequest?: try {
      guard case .storageBackupCreateRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .storageBackupRestoreRequest?: try {
      guard case .storageBackupRestoreRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .systemPowerInfoRequest?: try {
      guard case .systemPowerInfoRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .systemPowerInfoResponse?: try {
      guard case .systemPowerInfoResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .systemUpdateResponse?: try {
      guard case .systemUpdateResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .appExitRequest?: try {
      guard case .appExitRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .appLoadFileRequest?: try {
      guard case .appLoadFileRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .appButtonPressRequest?: try {
      guard case .appButtonPressRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .appButtonReleaseRequest?: try {
      guard case .appButtonReleaseRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .gpioSetPinMode?: try {
      guard case .gpioSetPinMode(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .gpioSetInputPull?: try {
      guard case .gpioSetInputPull(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .gpioGetPinMode?: try {
      guard case .gpioGetPinMode(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .gpioGetPinModeResponse?: try {
      guard case .gpioGetPinModeResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .gpioReadPin?: try {
      guard case .gpioReadPin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .gpioReadPinResponse?: try {
      guard case .gpioReadPinResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .gpioWritePin?: try {
      guard case .gpioWritePin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .appStateResponse?: try {
      guard case .appStateResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .storageTimestampRequest?: try {
      guard case .storageTimestampRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .storageTimestampResponse?: try {
      guard case .storageTimestampResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .propertyGetRequest?: try {
      guard case .propertyGetRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .propertyGetResponse?: try {
      guard case .propertyGetResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .appGetErrorRequest?: try {
      guard case .appGetErrorRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
    }()
    case .appGetErrorResponse?: try {
      guard case .appGetErrorResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }()
    case .appDataExchangeRequest?: try {
      guard case .appDataExchangeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .desktopIsLockedRequest?: try {
      guard case .desktopIsLockedRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .desktopUnlockRequest?: try {
      guard case .desktopUnlockRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Main, rhs: PB_Main) -> Bool {
    if lhs.commandID != rhs.commandID {return false}
    if lhs.commandStatus != rhs.commandStatus {return false}
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Region"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .same(proto: "bands"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.bands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bands, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Region, rhs: PB_Region) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.bands != rhs.bands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Region.Band: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = PB_Region.protoMessageName + ".Band"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .standard(proto: "power_limit"),
    4: .standard(proto: "duty_cycle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.powerLimit) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.dutyCycle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularUInt32Field(value: self.end, fieldNumber: 2)
    }
    if self.powerLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.powerLimit, fieldNumber: 3)
    }
    if self.dutyCycle != 0 {
      try visitor.visitSingularUInt32Field(value: self.dutyCycle, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Region.Band, rhs: PB_Region.Band) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.powerLimit != rhs.powerLimit {return false}
    if lhs.dutyCycle != rhs.dutyCycle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
